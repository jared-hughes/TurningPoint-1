#pragma config(Sensor, in1, clawPot, sensorPotentiometer)
#pragma config(Sensor, dgtl1, leftEncoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl3, rightEncoder, sensorQuadEncoder)
#pragma config(Motor, port1, flywheelLeft, tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor, port2, clawFlip, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port3, driveLeftFront, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor, port4, driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor, port5, liftBottom, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port6, liftTop, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port7, driveRightFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port8, driveRightBack, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor, port9, conveyor, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor, port10, flywheelRight, tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)

#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

// Include custom libraries
#include "helpers.c"
#include "movement_atomic.c"

// ---- MAIN CONTROL

void pre_auton()
{
	// stop tasks while changing from autonomous to usercontrol
	bStopTasksBetweenModes = true;
}

task autonomous()
{
	// 85 is p much max speed since speed is nonlinear, 60 is reasonable speed
	bool isRed = false;
	// practice as if blue, then negative of drive angles for red
	angleMultiplier = isRed ? -1 : 1;
	// false --> starting position closer to flags
	// true --> starting position closer to posts
	bool startNearFlags = true;
	// completely different routines by sides
	if (startNearFlags)
	{
		// start at edge of starting tile closer to the flag
		// drive forward then turn to shoot toward high flag
		driveDistance(12);
		rotateAngle(90);
		shoot(3, 30);
		// pick up cap
		rotateAngle(-45);
		driveDistance(20);
		// TODO: lift to pick up the cap
		// drive to pole
		driveDistance(-20);
		rotateAngle(-135);
		driveDistance(24);
		rotateAngle(-90);
		driveDistance(24);
		// TODO: lift the lift
		flipClaw();
	}
	else
	{
	}
	angleMultiplier = 1;
}

task usercontrol()
{
	//fliperoonie with the potentiometer
	while (true)
	{
		if (vexRT[Btn5D])
		{
			while (SensorValue[clawPot] < 2700)
			{
				motor[clawFlip] = -127;
			}
			motor[clawFlip] = 0;
		}
		else if (vexRT[Btn5U])
		{
			while (SensorValue[clawPot] > 1000)
			{
				motor[clawFlip] = 127;
			}
			motor[clawFlip] = 0;
		}
		// testing out durations
		// change the time inside waitMS directly after TOCALIBRATE comments
		if (vexRT[Btn8D])
		{
			driveDistance(24);
		}
		if (vexRT[Btn8R])
		{
			rotateAngle(360);
		}
		if (vexRT[Btn8L])
		{
			flipClaw();
		}
		doDrive();
		doArms();
		doConveyor();
		doFlywheel();
	}
}
